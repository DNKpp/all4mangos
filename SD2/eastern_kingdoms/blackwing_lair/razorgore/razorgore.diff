diff --git a/scripts/eastern_kingdoms/blackwing_lair/blackwing_lair.h b/scripts/eastern_kingdoms/blackwing_lair/blackwing_lair.h
index c459f11..4bfcd89 100644
--- a/scripts/eastern_kingdoms/blackwing_lair/blackwing_lair.h
+++ b/scripts/eastern_kingdoms/blackwing_lair/blackwing_lair.h
@@ -18,7 +18,16 @@ enum
     TYPE_CHROMAGGUS             = 6,
     TYPE_NEFARIAN               = 7,
 
+    DATA_RAZORGORE              = 8,
+    DATA_GRETHOK                = 9,
+    DATA_ORB_TRIGGER            = 10,
+
+    DATA_ORB_OF_DOMINATION      = 11,
+
     NPC_RAZORGORE               = 12435,
+    NPC_GRETHOK                 = 12557,
+    NPC_BLACKWING_GUARDSMAN     = 14456,
+    NPC_ORB_TRIGGER             = 14449,
     NPC_VAELASTRASZ             = 13020,
     NPC_LASHLAYER               = 12017,
     NPC_FIREMAW                 = 11983,
@@ -35,39 +44,8 @@ enum
     GO_DOOR_CHROMAGGUS_SIDE     = 179116,
     GO_DOOR_CHROMAGGUS_EXIT     = 179117,
     GO_DOOR_VAELASTRASZ         = 179364,
-    GO_DOOR_LASHLAYER           = 179365
-};
-
-class MANGOS_DLL_DECL instance_blackwing_lair : public ScriptedInstance
-{
-    public:
-        instance_blackwing_lair(Map* pMap);
-        ~instance_blackwing_lair() {}
-
-        void Initialize();
-        bool IsEncounterInProgress() const;
-
-        void OnObjectCreate(GameObject* pGo);
-
-        void SetData(uint32 uiType, uint32 uiData);
-        uint32 GetData(uint32 uiType);
-
-        const char* Save() { return m_strInstData.c_str(); }
-        void Load(const char* chrIn);
-
-    protected:
-        std::string m_strInstData;
-        uint32 m_auiEncounter[MAX_ENCOUNTER];
-
-        // Doors
-        uint64 m_uiRazorgoreEnterDoorGUID;
-        uint64 m_uiRazorgoreExitDoorGUID;
-        uint64 m_uiVaelastraszDoorGUID;
-        uint64 m_uiLashlayerDoorGUID;
-        uint64 m_uiChromaggusEnterDoorGUID;
-        uint64 m_uiChromaggusExitDoorGUID;
-        uint64 m_uiChromaggusSideDoorGUID;
-        uint64 m_uiNefarianDoorGUID;
+    GO_DOOR_LASHLAYER           = 179365,
+    GO_ORB_OF_DOMINATION        = 177808,
+    GO_BLACK_DRAGON_EGG         = 177807,
 };
-
 #endif
diff --git a/scripts/eastern_kingdoms/blackwing_lair/boss_razorgore.cpp b/scripts/eastern_kingdoms/blackwing_lair/boss_razorgore.cpp
index 82c2493..6c7bb91 100644
--- a/scripts/eastern_kingdoms/blackwing_lair/boss_razorgore.cpp
+++ b/scripts/eastern_kingdoms/blackwing_lair/boss_razorgore.cpp
@@ -36,13 +36,378 @@ enum
     SPELL_WARSTOMP              = 24375,
     SPELL_FIREBALL_VOLLEY       = 22425,
     SPELL_CONFLAGRATION         = 23023,
+    SPELL_MIND_EXHAUSTION       = 23958,
+    SPELL_DRAGON_ORB            = 19869,
+    SPELL_USE_DRAGON_ORB        = 23018,
+    SPELL_DESTROY_EGG           = 19873,
+    SPELL_FIREBALL              = 23024,
+    SPELL_WARMING_FLAMES        = 23040,
+    SPELL_BLUE_BEAM             = 22203,
+
+    MAX_DRAGONKINS              = 12,
+    MAX_ORKS                    = 40,
+    MAX_EGGS                    = 30,
+
+    NPC_DEATH_TALON_DRAGONSPAWN = 12422,            // dragonkin
+    NPC_BLACKWING_LEGIONNAIRE   = 12416,            // orc
+    NPC_BLACKWING_MAGE          = 12420,            // orc
+
+    FACTION_RAZORGORE           = 103,
+};
+
+enum Phases
+{
+    PHASE_NONE,
+    PHASE_GRETHOK,
+    PHASE_EGGS,
+    PHASE_FIGHT,
+};
+
+struct sSpawnLocation
+{
+    float m_fX, m_fY, m_fZ;
+};
+
+struct sSpawnLocation aEggSpawnLocs[MAX_EGGS] =
+{
+    { -7596.41f, -1001.11f, 408.491f },
+    { -7596.41f, -1001.11f, 408.491f },
+    { -7585.98f, -1022.83f, 408.491f },
+    { -7577.36f, -1035.26f, 408.491f },
+    { -7560.38f, -1057.63f, 408.491f },
+    { -7589.32f, -1051.47f, 408.158f },
+    { -7579.65f, -1050.32f, 408.158f },
+    { -7604.91f, -1059.74f, 408.158f },
+    { -7583.57f, -1075.18f, 408.491f },
+    { -7576.93f, -1085.41f, 413.382f },
+    { -7621.82f, -1061.06f, 408.491f},
+    { -7577.58f, -1090.8f,  413.382f },
+    { -7569.34f, -1079.7f,  413.382f },
+    { -7567.53f, -1087.96f, 413.382f },
+    { -7568.46f, -1094.13f, 413.382f },
+    { -7579.51f, -1066.71f, 408.49f  },
+    { -7542.58f, -1068.73f, 408.491f },
+    { -7596.04f, -1094.38f, 408.491f },
+    { -7611.5f,  -1022.25f, 413.382f },
+    { -7587.81f, -1036.5f,  408.157f },
+    { -7599.08f, -1046.0f,  408.157f },
+    { -7600.33f, -1081.82f, 408.49f  },
+    { -7568.42f, -1059.21f, 408.49f  },
+    { -7594.38f, -1108.26f, 408.491f },
+    { -7610.73f, -1035.17f, 408.491f },
+    { -7639.49f, -1047.0f,  408.49f  },
+    { -7625.56f, -1043.2f,  408.49f  },
+    { -7620.48f, -1078.42f, 408.491f },
+    { -7626.59f, -1019.81f, 413.381f },
+    { -7622.5f,  -1009.51f, 413.381f }
+};
+
+// Add Spawn Positions
+struct sSpawnLocation aSpawnLocs[8] =
+{
+    // east (north to south)
+    { -7608.409f, -1116.690f, 407.199f },
+    { -7622.761f, -1094.909f, 407.205f },
+    { -7643.701f, -1064.859f, 407.204f },
+    { -7658.567f, -1043.317f, 407.199f },
+    // west (north to south)
+    { -7532.629f, -1064.694f, 407.198f },
+    { -7548.185f, -1041.537f, 407.205f },
+    { -7563.438f, -1012.763f, 407.205f },
+    { -7583.950f,  -991.112f, 407.199f }
+};
+
+struct sSpawnLocation aAddDespawnWPs[2] =
+{
+    { -7595.694f, -1053.374f, 408.157f },
+    { -7555.137f, -1024.815f, 408.490f }
 };
 
+/*######
+## mob_blackwing_orb_trigger
+######*/
+struct MANGOS_DLL_DECL mob_blackwing_orb_triggerAI : public Scripted_NoMovementAI
+{
+    mob_blackwing_orb_triggerAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_uiRazorgoreGUID = m_pInstance->GetData64(DATA_RAZORGORE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        if (m_pInstance->GetData(TYPE_RAZORGORE) != DONE)
+            SpawnEggs();
+        Reset();
+    }
+    
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiAddSummonTimer;
+    uint32 m_uiEggCounter;
+    Phases m_Phase;
+    uint8  m_uiWaypoint;
+
+    uint64 m_uiRazorgoreGUID;
+    std::list<uint64> m_uiDragonkinGUIDs;
+    std::list<uint64> m_uiOrkGUIDs;
+    std::list<uint64> m_uiDragonEggGUIDs;
+
+    void Reset()
+    {
+        m_uiEggCounter          = 0;
+        m_Phase                 = PHASE_NONE;
+
+        m_uiAddSummonTimer      = 3000;
+        m_uiWaypoint            = 0;
+        UnsummonAdds();
+        RespawnAllEggs();
+    }
+
+    // add destroyed edd counter, if greater MAX_EGGS switch phase and heal razorgore to full
+    void DestroyEgg()
+    {
+        m_uiEggCounter++;
+        if (m_uiEggCounter >= 3)
+        {
+            m_Phase = PHASE_FIGHT;
+            if (Creature *pRazorgore = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_RAZORGORE)))
+            {
+                pRazorgore->GetCharmerOrOwner()->RemoveAura(SPELL_USE_DRAGON_ORB, EFFECT_INDEX_0);  // remove use dragon orb from razorgore-charmer
+                pRazorgore->RemoveAurasDueToSpell(19832);                                           // remove mind controle from razorgore
+                pRazorgore->CastSpell(pRazorgore, SPELL_WARMING_FLAMES, true);
+            }
+            AddsMoveToDespawn();
+        }
+    }
+
+    // move adds to current WP, to despawn
+    void AddsMoveToDespawn()
+    {
+        for (std::list<uint64>::iterator itr = m_uiDragonkinGUIDs.begin(); itr != m_uiDragonkinGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+            {
+                if (m_uiWaypoint < 2)
+                {
+                    pCreature->GetMotionMaster()->Clear();
+                    pCreature->SetSpeedRate(MOVE_WALK, 4);
+                    pCreature->GetMotionMaster()->MovePoint(m_uiWaypoint, aAddDespawnWPs[m_uiWaypoint].m_fX, aAddDespawnWPs[m_uiWaypoint].m_fY, aAddDespawnWPs[m_uiWaypoint].m_fZ);
+                }
+                else
+                    pCreature->ForcedDespawn();
+            }
+        }
+
+        for (std::list<uint64>::iterator itr = m_uiOrkGUIDs.begin(); itr != m_uiOrkGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+            {
+                if (m_uiWaypoint < 2)
+                {
+                    pCreature->GetMotionMaster()->Clear();
+                    pCreature->SetSpeedRate(MOVE_WALK, 4);
+                    pCreature->GetMotionMaster()->MovePoint(m_uiWaypoint, aAddDespawnWPs[m_uiWaypoint].m_fX, aAddDespawnWPs[m_uiWaypoint].m_fY, aAddDespawnWPs[m_uiWaypoint].m_fZ);
+                }
+                else
+                    pCreature->ForcedDespawn();
+            }
+        }
+    }
+
+    // if all adds at current waypoint set to next WP
+    void CheckAddMovement()
+    {
+        for (std::list<uint64>::iterator itr = m_uiDragonkinGUIDs.begin(); itr != m_uiDragonkinGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+            {
+                if (pCreature->GetDistance(aAddDespawnWPs[m_uiWaypoint].m_fX, aAddDespawnWPs[m_uiWaypoint].m_fY, aAddDespawnWPs[m_uiWaypoint].m_fZ) > 3)
+                    return;
+            }
+        }
+
+        for (std::list<uint64>::iterator itr = m_uiOrkGUIDs.begin(); itr != m_uiOrkGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+            {
+                if (pCreature->GetDistance(aAddDespawnWPs[m_uiWaypoint].m_fX, aAddDespawnWPs[m_uiWaypoint].m_fY, aAddDespawnWPs[m_uiWaypoint].m_fZ) > 3)
+                    return;
+            }
+        }
+        m_uiWaypoint++;
+        AddsMoveToDespawn();
+    }
+
+    // attacks the current charmer of razorgore
+    void AttackOrbUser(Creature *pCreature)
+    {
+        if (!pCreature)
+            return;
+
+        Creature *pRazorgore = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_RAZORGORE));
+        if (pRazorgore && pRazorgore->isCharmed())
+        {
+            if (Unit *pUnit = pRazorgore->GetCharmerOrOwner())
+            {
+                pCreature->GetMotionMaster()->MoveChase(pUnit);
+                pCreature->AddThreat(pUnit, 10000);
+            }
+        }
+
+    }
+
+    Phases GetPhase() { return m_Phase; }
+
+    // first spawn of eggs
+    void SpawnEggs()
+    {
+        for(uint32 i = 0; i < MAX_EGGS; i++)
+            m_uiDragonEggGUIDs.push_back(m_creature->SummonGameObject(177807, aEggSpawnLocs[i].m_fX, aEggSpawnLocs[i].m_fY, aEggSpawnLocs[i].m_fZ, urand(0, M_PI_F * 2), TEMPSUMMON_MANUAL_DESPAWN)->GetGUID());
+    }
+
+    // the respawn of eggs
+    void RespawnAllEggs()
+    {
+        uint32 i = 0;
+        for (std::list<uint64>::iterator itr = m_uiDragonEggGUIDs.begin(); itr != m_uiDragonEggGUIDs.end(); ++itr)
+        {
+            GameObject *pGo = m_creature->GetMap()->GetGameObject(*itr);
+            if (!pGo)
+                *itr = m_creature->SummonGameObject(177807, aEggSpawnLocs[i].m_fX, aEggSpawnLocs[i].m_fY, aEggSpawnLocs[i].m_fZ, urand(0, M_PI_F * 2), TEMPSUMMON_MANUAL_DESPAWN)->GetGUID();
+            i++;
+        }
+    }
+
+    // unsummon all adds and delete GUID lists
+    void UnsummonAdds()
+    {
+        for (std::list<uint64>::iterator itr = m_uiDragonkinGUIDs.begin(); itr != m_uiDragonkinGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+                m_creature->ForcedDespawn();
+        }
+
+        for (std::list<uint64>::iterator itr = m_uiOrkGUIDs.begin(); itr != m_uiOrkGUIDs.end(); ++itr)
+        {
+            if (Creature *pCreature = m_creature->GetMap()->GetCreature(*itr))
+                m_creature->ForcedDespawn();
+        }
+        m_uiDragonkinGUIDs.clear();
+        m_uiOrkGUIDs.clear();
+    }
+
+    void SummonedCreatureDespawn(Creature *pCreature)
+    {
+        if (pCreature->GetEntry() == NPC_DEATH_TALON_DRAGONSPAWN)
+            m_uiDragonkinGUIDs.remove(pCreature->GetGUID());
+        else if (pCreature->GetEntry() == NPC_BLACKWING_LEGIONNAIRE || pCreature->GetEntry() == NPC_BLACKWING_MAGE)
+            m_uiOrkGUIDs.remove(pCreature->GetGUID());
+    }
+
+    void Aggro (Unit *who) {}
+
+    void MoveInLineOfSight(Unit* who) {}
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        // reset if razorgore is outfight, moving home and phase is not "PHASE_GRETHOK"
+        Creature* pRazorgore = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_RAZORGORE));
+        if (!pRazorgore || !pRazorgore->isInCombat())
+        {
+            if (m_Phase != PHASE_NONE && pRazorgore->GetMotionMaster()->GetCurrentMovementGeneratorType() == HOME_MOTION_TYPE)
+            {
+                Reset();
+                return;
+            }
+        }
+
+        if (m_Phase == PHASE_NONE)
+        {
+            Creature *pGrethok = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_GRETHOK));
+            if (pGrethok && pGrethok->isInCombat())
+            {
+                Creature *pRazorgore = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_RAZORGORE));
+                if (!pRazorgore || pRazorgore->isDead())
+                    return;
+
+                m_Phase = PHASE_GRETHOK;
+                pRazorgore->SetInCombatWithZone();
+            }
+            else
+                return;
+        }
+        // if grethok is dead, change phase
+        else if (m_Phase == PHASE_GRETHOK)
+        {
+            Creature *pGrethok = m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_GRETHOK));
+            if (!pGrethok || pGrethok->isDead())
+                m_Phase = PHASE_EGGS;
+            else
+                return;
+        }
+        else if (m_Phase == PHASE_FIGHT)
+        {
+            // if GUID lists are empty, return;
+            if (m_uiDragonkinGUIDs.empty() && m_uiOrkGUIDs.empty())
+                return;
+
+            CheckAddMovement();
+            return;
+        }
+        else if (m_Phase != PHASE_EGGS)
+            return;
+
+        // summon adds in all 8 rooms
+        if (m_uiAddSummonTimer <= uiDiff)
+        {
+            for (uint8 i = 0; i < 8; i++)
+            {
+                Creature *pCreature = NULL;
+                if (urand(0, 1))
+                {
+                    if (m_uiDragonkinGUIDs.size() < MAX_DRAGONKINS)
+                        pCreature = m_creature->SummonCreature(NPC_DEATH_TALON_DRAGONSPAWN, aSpawnLocs[i].m_fX, aSpawnLocs[i].m_fY, aSpawnLocs[i].m_fZ, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+
+                    if (pCreature)
+                        m_uiDragonkinGUIDs.push_back(pCreature->GetGUID());
+                }
+                else
+                {
+                    if (m_uiOrkGUIDs.size() < MAX_ORKS)
+                    {
+                        if (urand(0, 1))
+                            pCreature = m_creature->SummonCreature(NPC_BLACKWING_LEGIONNAIRE, aSpawnLocs[i].m_fX, aSpawnLocs[i].m_fY, aSpawnLocs[i].m_fZ, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                        else
+                            pCreature = m_creature->SummonCreature(NPC_BLACKWING_MAGE, aSpawnLocs[i].m_fX, aSpawnLocs[i].m_fY, aSpawnLocs[i].m_fZ, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+
+                        if (pCreature)
+                            m_uiOrkGUIDs.push_back(pCreature->GetGUID());
+                    }
+                }
+                AttackOrbUser(pCreature);
+            }
+            m_uiAddSummonTimer = 15000;
+        }
+        else
+            m_uiAddSummonTimer -= uiDiff;
+    }
+};
+
+CreatureAI* GetAI_mob_blackwing_orb_trigger(Creature* pCreature)
+{
+    return new mob_blackwing_orb_triggerAI(pCreature);
+}
+
+/*######
+## boss_razorgore
+######*/
 struct MANGOS_DLL_DECL boss_razorgoreAI : public ScriptedAI
 {
     boss_razorgoreAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
         m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SpellEntry* TempSpell = (SpellEntry*)GetSpellStore()->LookupEntry(SPELL_USE_DRAGON_ORB);
+        TempSpell->EffectImplicitTargetA[0] = TARGET_SELF;
+        TempSpell->EffectImplicitTargetA[1] = TARGET_SELF;
+
         Reset();
     }
 
@@ -59,13 +424,24 @@ struct MANGOS_DLL_DECL boss_razorgoreAI : public ScriptedAI
         m_uiWarStompTimer       = 35000;
         m_uiConflagrationTimer  = 12000;
         m_uiFireballVolleyTimer = 7000;
+    }
 
+    void DamageTaken(Unit *pWho, uint32 &uiDmg)
+    {
+        if (mob_blackwing_orb_triggerAI *pTriggerAI = (mob_blackwing_orb_triggerAI*)m_creature->GetMap()->GetCreature(m_pInstance->GetData64(DATA_ORB_TRIGGER))->AI())
+        {
+            if (pTriggerAI->GetPhase() != PHASE_FIGHT && uiDmg >= m_creature->GetHealth())
+            {
+                uiDmg = 0;
+                //DoCastSpellIfCan(m_creature, 
+            }
+        }
     }
 
     void Aggro(Unit* pWho)
     {
         // TODO Temporarily add this InstData setting, must be started with Phase 1 which is not yet implemented
-        if (m_pInstance)
+        if (m_pInstance && m_pInstance->GetData(TYPE_RAZORGORE) != IN_PROGRESS)
             m_pInstance->SetData(TYPE_RAZORGORE, IN_PROGRESS);
     }
 
@@ -142,12 +518,69 @@ CreatureAI* GetAI_boss_razorgore(Creature* pCreature)
     return new boss_razorgoreAI(pCreature);
 }
 
+/*######
+## go_orb_of_domintaion
+######*/
+bool GOUse_go_orb_of_domintaion(Player* pPlayer, GameObject* pGo)
+{
+    if (ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData())
+    {
+        // if exhausted return
+        if (!pPlayer || pPlayer->HasAura(SPELL_MIND_EXHAUSTION, EFFECT_INDEX_0))
+            return true;
+
+        // if razorgore is already charmed
+        mob_blackwing_orb_triggerAI *pTriggerAI = (mob_blackwing_orb_triggerAI*)pPlayer->GetMap()->GetCreature(pInstance->GetData64(DATA_ORB_TRIGGER))->AI();
+        Creature *pCreature = pPlayer->GetMap()->GetCreature(pInstance->GetData64(DATA_RAZORGORE));
+        if (!pCreature || pCreature->isCharmed() || !pTriggerAI || pTriggerAI->GetPhase() != PHASE_EGGS)
+            return true;
+
+        pPlayer->CastSpell(pCreature, SPELL_DRAGON_ORB, true);
+    }
+    else
+        return true;
+
+    return false;
+}
+
+/*######
+## go_dark_dragon_egg
+######*/
+bool GOUse_go_dark_dragon_egg(Player* pPlayer, GameObject* pGo)
+{
+    if (ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData())
+    {
+        if (mob_blackwing_orb_triggerAI *pTrigger = (mob_blackwing_orb_triggerAI*)pGo->GetMap()->GetCreature(pInstance->GetData64(DATA_ORB_TRIGGER))->AI())
+            pTrigger->DestroyEgg();
+
+        TemporarySummonGO *pTemp = (TemporarySummonGO*)pGo;
+        if (pTemp)
+            pTemp->UnSummon();
+    }
+    return false;
+}
+
 void AddSC_boss_razorgore()
 {
-    Script* pNewScript;
+    Script* newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_razorgore";
+    newscript->GetAI = &GetAI_boss_razorgore;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_blackwing_orb_trigger";
+    newscript->GetAI = &GetAI_mob_blackwing_orb_trigger;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "go_orb_of_domintaion";
+    newscript->pGOUse = &GOUse_go_orb_of_domintaion;
+    newscript->RegisterSelf();
 
-    pNewScript = new Script;
-    pNewScript->Name = "boss_razorgore";
-    pNewScript->GetAI = &GetAI_boss_razorgore;
-    pNewScript->RegisterSelf();
+    newscript = new Script;
+    newscript->Name = "go_dark_dragon_egg";
+    newscript->pGOUse = &GOUse_go_dark_dragon_egg;
+    newscript->RegisterSelf();
 }
diff --git a/scripts/eastern_kingdoms/blackwing_lair/instance_blackwing_lair.cpp b/scripts/eastern_kingdoms/blackwing_lair/instance_blackwing_lair.cpp
index 3bf2b7d..a64415e 100644
--- a/scripts/eastern_kingdoms/blackwing_lair/instance_blackwing_lair.cpp
+++ b/scripts/eastern_kingdoms/blackwing_lair/instance_blackwing_lair.cpp
@@ -24,159 +24,243 @@ EndScriptData */
 #include "precompiled.h"
 #include "blackwing_lair.h"
 
-
-instance_blackwing_lair::instance_blackwing_lair(Map* pMap) : ScriptedInstance(pMap),
-    m_uiRazorgoreEnterDoorGUID(0),
-    m_uiRazorgoreExitDoorGUID(0),
-    m_uiVaelastraszDoorGUID(0),
-    m_uiLashlayerDoorGUID(0),
-    m_uiChromaggusEnterDoorGUID(0),
-    m_uiChromaggusExitDoorGUID(0),
-    m_uiChromaggusSideDoorGUID(0),
-    m_uiNefarianDoorGUID(0)
+struct MANGOS_DLL_DECL instance_blackwing_lair : public ScriptedInstance
 {
-    Initialize();
-}
+    instance_blackwing_lair(Map* pMap) : ScriptedInstance(pMap) {Initialize();};
 
-void instance_blackwing_lair::Initialize()
-{
-    memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
-}
+    void Initialize()
+    {
+        memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
+        m_uiRazorgoreEnterDoorGUID  = 0;
+        m_uiRazorgoreExitDoorGUID   = 0;
+        m_uiVaelastraszDoorGUID     = 0;
+        m_uiLashlayerDoorGUID       = 0;
+        m_uiChromaggusEnterDoorGUID = 0;
+        m_uiChromaggusExitDoorGUID  = 0;
+        m_uiChromaggusSideDoorGUID  = 0;
+        m_uiNefarianDoorGUID        = 0;
+        m_uiOrbOfDominationGUID     = 0;
+        m_uiRazagoreGUID            = 0;
+        m_uiGrethokGUID             = 0;
+        m_uiOrbTriggerGUID          = 0;
+    }
 
-bool instance_blackwing_lair::IsEncounterInProgress() const
-{
-    for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+    std::string m_strInstData;
+    uint32 m_auiEncounter[MAX_ENCOUNTER];
+
+    // Doors
+    uint64 m_uiRazorgoreEnterDoorGUID;
+    uint64 m_uiRazorgoreExitDoorGUID;
+    uint64 m_uiVaelastraszDoorGUID;
+    uint64 m_uiLashlayerDoorGUID;
+    uint64 m_uiChromaggusEnterDoorGUID;
+    uint64 m_uiChromaggusExitDoorGUID;
+    uint64 m_uiChromaggusSideDoorGUID;
+    uint64 m_uiOrbOfDominationGUID;
+    uint64 m_uiNefarianDoorGUID;
+
+    // Encounters & Trash
+    uint64 m_uiRazagoreGUID;
+    uint64 m_uiGrethokGUID;
+    uint64 m_uiOrbTriggerGUID;
+    std::list<uint64> m_uilBlackwingGuardsmanGUIDs;
+
+    bool IsEncounterInProgress() const
     {
-        if (m_auiEncounter[i] == IN_PROGRESS)
-            return true;
+        for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+        {
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                return true;
+        }
+        return false;
     }
-    return false;
-}
 
-void instance_blackwing_lair::OnObjectCreate(GameObject* pGo)
-{
-    switch(pGo->GetEntry())
+    void OnCreatureCreate(Creature *pCreature)
     {
-        case GO_DOOR_RAZORGORE_ENTER:
-            m_uiRazorgoreEnterDoorGUID = pGo->GetGUID();
-            break;
-        case GO_DOOR_RAZORGORE_EXIT:
-            m_uiRazorgoreExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[TYPE_RAZORGORE] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_DOOR_NEFARIAN:
-            m_uiNefarianDoorGUID = pGo->GetGUID();
-            break;
-        case GO_DOOR_CHROMAGGUS_ENTER:
-            m_uiChromaggusEnterDoorGUID = pGo->GetGUID();
-            break;
-        case GO_DOOR_CHROMAGGUS_SIDE:
-            m_uiChromaggusSideDoorGUID = pGo->GetGUID();
+        switch(pCreature->GetEntry())
+        {
+        case NPC_RAZORGORE:
+            m_uiRazagoreGUID = pCreature->GetGUID();
             break;
-        case GO_DOOR_CHROMAGGUS_EXIT:
-            m_uiChromaggusExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[TYPE_CHROMAGGUS] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
+        case NPC_GRETHOK:
+            m_uiGrethokGUID = pCreature->GetGUID();
             break;
-        case GO_DOOR_VAELASTRASZ:
-            m_uiVaelastraszDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[TYPE_VAELASTRASZ] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
+        case NPC_ORB_TRIGGER:
+            m_uiOrbTriggerGUID = pCreature->GetGUID();
             break;
-        case GO_DOOR_LASHLAYER:
-            m_uiLashlayerDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[TYPE_LASHLAYER] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
+        case NPC_BLACKWING_GUARDSMAN:
+            m_uilBlackwingGuardsmanGUIDs.push_back(pCreature->GetGUID());
             break;
+        }
     }
-}
 
-void instance_blackwing_lair::SetData(uint32 uiType, uint32 uiData)
-{
-    switch(uiType)
+    uint64 GetData64(uint32 uiTypeID)
     {
-        case TYPE_RAZORGORE:
-            m_auiEncounter[uiType] = uiData;
-            DoUseDoorOrButton(m_uiRazorgoreEnterDoorGUID);
-            if(uiData == DONE)
-                DoUseDoorOrButton(m_uiRazorgoreExitDoorGUID);
-            break;
-        case TYPE_VAELASTRASZ:
-            m_auiEncounter[uiType] = uiData;
-            // Prevent the players from running back to the first room
-            DoUseDoorOrButton(m_uiRazorgoreExitDoorGUID);
-            if(uiData == DONE)
-                DoUseDoorOrButton(m_uiVaelastraszDoorGUID);
-            break;
-        case TYPE_LASHLAYER:
-            m_auiEncounter[uiType] = uiData;
-            if(uiData == DONE)
-                DoUseDoorOrButton(m_uiLashlayerDoorGUID);
-            break;
-        case TYPE_FIREMAW:
-        case TYPE_EBONROC:
-        case TYPE_FLAMEGOR:
-            m_auiEncounter[uiType] = uiData;
-            break;
-        case TYPE_CHROMAGGUS:
-            m_auiEncounter[uiType] = uiData;
-            DoUseDoorOrButton(m_uiChromaggusEnterDoorGUID);
-            if (uiData == DONE)
-                DoUseDoorOrButton(m_uiChromaggusExitDoorGUID);
-            break;
-        case TYPE_NEFARIAN:
-            m_auiEncounter[uiType] = uiData;
-            DoUseDoorOrButton(m_uiNefarianDoorGUID);
-            break;
+        switch(uiTypeID)
+        {
+        case DATA_RAZORGORE:
+            return m_uiRazagoreGUID;
+        case DATA_ORB_OF_DOMINATION:
+            return m_uiOrbOfDominationGUID;
+        case DATA_GRETHOK:
+            return m_uiGrethokGUID;
+        case DATA_ORB_TRIGGER:
+            return m_uiOrbTriggerGUID;
+        }
+        return NULL;
+    }
+
+    void OnObjectCreate(GameObject* pGo)
+    {
+        switch(pGo->GetEntry())
+        {
+            case GO_DOOR_RAZORGORE_ENTER:
+                m_uiRazorgoreEnterDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_RAZORGORE_EXIT:
+                m_uiRazorgoreExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[TYPE_RAZORGORE] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_DOOR_NEFARIAN:
+                m_uiNefarianDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_CHROMAGGUS_ENTER:
+                m_uiChromaggusEnterDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_CHROMAGGUS_SIDE:
+                m_uiChromaggusSideDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_CHROMAGGUS_EXIT:
+                m_uiChromaggusExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[TYPE_CHROMAGGUS] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_DOOR_VAELASTRASZ:
+                m_uiVaelastraszDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[TYPE_VAELASTRASZ] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_DOOR_LASHLAYER:
+                m_uiLashlayerDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[TYPE_LASHLAYER] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_ORB_OF_DOMINATION:
+                m_uiOrbOfDominationGUID = pGo->GetGUID();
+                break;
+            case GO_BLACK_DRAGON_EGG:
+                pGo->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                break;
+        }
     }
 
-    if (uiData == DONE)
+    void SetData(uint32 uiType, uint32 uiData)
     {
-        OUT_SAVE_INST_DATA;
+        switch(uiType)
+        {
+            case TYPE_RAZORGORE:
+                debug_log("razorgore uiType = %u", uiType);
+                DoUseDoorOrButton(m_uiRazorgoreEnterDoorGUID);
+                if(uiData == DONE)
+                    DoUseDoorOrButton(m_uiRazorgoreExitDoorGUID);
+                else if (uiData == FAIL)
+                {
+                    // respawn Grethok adds
+                    for (std::list<uint64>::iterator itr = m_uilBlackwingGuardsmanGUIDs.begin(); itr != m_uilBlackwingGuardsmanGUIDs.end(); ++itr)
+                    {
+                        if (Creature *pCreature = instance->GetCreature(*itr))
+                        {
+                            if (pCreature->isDead())
+                                pCreature->Respawn();
+                        }
+                    }
+                    // respawn Grethok the Controler
+                    if (Creature *pGrethok = instance->GetCreature(m_uiGrethokGUID))
+                    {
+                        if (pGrethok->isDead())
+                            pGrethok->Respawn();
+                    }
+                    uiData = NOT_STARTED;
+                }
+                m_auiEncounter[uiType] = uiData;
+                break;
+            case TYPE_VAELASTRASZ:
+                m_auiEncounter[uiType] = uiData;
+                // Prevent the players from running back to the first room
+                DoUseDoorOrButton(m_uiRazorgoreExitDoorGUID);
+                if(uiData == DONE)
+                    DoUseDoorOrButton(m_uiVaelastraszDoorGUID);
+                break;
+            case TYPE_LASHLAYER:
+                m_auiEncounter[uiType] = uiData;
+                if(uiData == DONE)
+                    DoUseDoorOrButton(m_uiLashlayerDoorGUID);
+                break;
+            case TYPE_FIREMAW:
+            case TYPE_EBONROC:
+            case TYPE_FLAMEGOR:
+                m_auiEncounter[uiType] = uiData;
+                break;
+            case TYPE_CHROMAGGUS:
+                m_auiEncounter[uiType] = uiData;
+                DoUseDoorOrButton(m_uiChromaggusEnterDoorGUID);
+                if (uiData == DONE)
+                    DoUseDoorOrButton(m_uiChromaggusExitDoorGUID);
+                break;
+            case TYPE_NEFARIAN:
+                m_auiEncounter[uiType] = uiData;
+                DoUseDoorOrButton(m_uiNefarianDoorGUID);
+                break;
+        }
 
-        std::ostringstream saveStream;
-        saveStream << m_auiEncounter[0] << " " << m_auiEncounter[1] << " " << m_auiEncounter[2] << " "
-            << m_auiEncounter[3] << " " << m_auiEncounter[4] << " " << m_auiEncounter[5] << " "
-            << m_auiEncounter[6] << " " << m_auiEncounter[7];
+        if (uiData == DONE)
+        {
+            OUT_SAVE_INST_DATA;
 
-        m_strInstData = saveStream.str();
+            std::ostringstream saveStream;
+            saveStream << m_auiEncounter[0] << " " << m_auiEncounter[1] << " " << m_auiEncounter[2] << " "
+                << m_auiEncounter[3] << " " << m_auiEncounter[4] << " " << m_auiEncounter[5] << " "
+                << m_auiEncounter[6] << " " << m_auiEncounter[7];
 
-        SaveToDB();
-        OUT_SAVE_INST_DATA_COMPLETE;
+            m_strInstData = saveStream.str();
+
+            SaveToDB();
+            OUT_SAVE_INST_DATA_COMPLETE;
+        }
     }
-}
 
-void instance_blackwing_lair::Load(const char* chrIn)
-{
-    if (!chrIn)
+    void Load(const char* chrIn)
     {
-        OUT_LOAD_INST_DATA_FAIL;
-        return;
-    }
+        if (!chrIn)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
 
-    OUT_LOAD_INST_DATA(chrIn);
+        OUT_LOAD_INST_DATA(chrIn);
 
-    std::istringstream loadStream(chrIn);
-    loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2] >> m_auiEncounter[3]
-        >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7];
+        std::istringstream loadStream(chrIn);
+        loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2] >> m_auiEncounter[3]
+            >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7];
 
-    for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
-    {
-        if (m_auiEncounter[i] == IN_PROGRESS)
-            m_auiEncounter[i] = NOT_STARTED;
-    }
+        for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+        {
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                m_auiEncounter[i] = NOT_STARTED;
+        }
 
-    OUT_LOAD_INST_DATA_COMPLETE;
-}
+        OUT_LOAD_INST_DATA_COMPLETE;
+    }
 
-uint32 instance_blackwing_lair::GetData(uint32 uiType)
-{
-    if (uiType < MAX_ENCOUNTER)
-        return m_auiEncounter[uiType];
+    uint32 GetData(uint32 uiType)
+    {
+        if (uiType < MAX_ENCOUNTER)
+            return m_auiEncounter[uiType];
 
-    return 0;
-}
+        return 0;
+    }
+};
 
 InstanceData* GetInstanceData_instance_blackwing_lair(Map* pMap)
 {
